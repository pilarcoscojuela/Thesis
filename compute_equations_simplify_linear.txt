// ========== INITIAL SETUP ========== 
// Load parameter definitions and ring setup
load "initial_setup.txt";

// ========== FUNCTION DEFINITIONS ========== 

// Reduce exponents in a polynomial modulo (q-1)
function reduce_exponents_S(poly)
    terms := Terms(poly);
    vars := [S.i : i in [1..num_vars]];
    result := Zero(S);
    for t in terms do
        exp_vec := [Degree(t, v) mod (q - 1) : v in vars];
        coef := Coefficients(t)[1];
        result +:= coef * Monomial(S, exp_vec);
    end for;
    return result;
end function;

// Apply reduce_exponents_S to each polynomial in a vector
function reduce_vector_S(vec)
    return [reduce_exponents_S(p) : p in vec];
end function;

// Compute x^(2^k) mod (q-1) via exponentiation by squaring in batches
function power_mod(x, exp)
    if exp eq 1 then
        return x;
    end if;
    modulus := q - 1;
    k := Ilog2(exp); // Number of squarings needed
    res := x;
    remaining_squarings := k;
    batch_size := 7; // Adjust based on q
    while remaining_squarings gt 0 do
        current_batch := Minimum(batch_size, remaining_squarings);
        for i in [1..current_batch] do
            res := res^2;
        end for;
        // Reduce exponents modulo (q-1) after the batch
        res := reduce_exponents_S(res);
        remaining_squarings -:= current_batch;
    end while;
    return res;
end function;

// Tensor-like product: row i of E with vector v using function power_mod
function tensor_bis(E, v)
    n := NumberOfRows(E);
    out := [Zero(S) : i in [1..n]];
    for i in [1..n] do
        out[i] := &*[power_mod(v[j],E[i][j]) : j in [1..n] | E[i][j] ne 0];
    end for;
    return out;
end function;




function remove_duplicates(list)
    for j in [1..#list] do
    while exists(t){i : i in [1..#list]| list[i] ne 0 and i gt j and list[i] eq list[j]} do
        list[t]:=0;
    end while;
    end for;
    list_2:=[];
    for i in [1..#list] do
        if list[i] ne 0 then
            list_2:= list_2 cat [list[i]];
        end if;
    end for;
    return list_2;
end function;

// Compute monomial list output from a exponential map (mat_exp) and the monomial list of the previous round (vec). 
//Use extra_components if there are affine maps
function compute_monomial_list(mat_exp, vec)
    rows := NumberOfRows(mat_exp);
    cols := NumberOfColumns(mat_exp);
    M1 := [[] : i in [1..rows]];
    M := [[] : i in [1..rows]];
    modified_vector := vec;
    for i in [1..rows] do
        for j in [1..cols] do
            if mat_exp[i][j] ne 0 then
                exps := [power_mod(modified_vector[j][k],mat_exp[i][j]) : k in [1..#modified_vector[j]]];
                M1[i] := M1[i] cat [exps];
            end if;
        end for;
        if #M1[i] gt 0 then
            // Compute all possible products of elements in M1[i]
            M[i] := [&*[terms[k] : k in [1..#terms]] : terms in CartesianProduct(M1[i])];
        end if;
    end for;
    return [reduce_vector_S(M[j]) : j in [1..#M]];
end function;


// Apply compute_monomial_list across a sequence of matrices
function compute_monomial_lists_sequence(matrices, vec)
    num_matrices := #matrices;
    rows:=NumberOfRows(matrices[1]);
    M := vec;
    for i in [1..num_matrices] do
        M := compute_monomial_list(matrices[i], M);
        M := [remove_duplicates(x) : x in M];
    end for;
    return M;
end function;

//Template lists


list_q1:=[ S.i: i in [1..ctes]];
list_q2:=[ S.(ctes+i): i in [1..ctes]];
list_q3:=[S.(2*ctes+i): i in [1..num_par/8]];
list_q4:=[S.(3*ctes+i): i in [1..num_par/8]];
list_q5:=[S.(4*ctes+i): i in [1..num_par/8]];
list_q6:=[S.(5*ctes+i): i in [1..num_par/8]];
list_q7:=[S.(6*ctes+i): i in [1..num_par/8]];
list_q8:=[S.(7*ctes+i): i in [1..num_par/8]];

list_q := [list_q1, list_q2, list_q3, list_q4, list_q5, list_q6, list_q7, list_q8];

function build_polynomial_list(monomial_lists)
    poly_list := [];
    for i in [1..#monomial_lists] do
        base := list_q[i];
        poly := &+[base[j] * monomial_lists[i][j] : j in [1..#monomial_lists[i]]];
        Append(~poly_list, poly);
    end for;
    return poly_list;
end function;


// Compute the public key from linear and exponential maps
function compute_public_key(linear_matrices, exp_matrices,initial_vector)
    num_matrices := #linear_matrices;
    L0_S := Matrix(S, 8, 8, [S!linear_matrices[1][i][j] : j in [1..8], i in [1..8]]);
    L0_traspuesta := Transpose(L0_S);
    y := initial_vector * L0_traspuesta;
    y := ElementToSequence(y);
    for i in [2..num_matrices] do
        y := tensor_bis(exp_matrices[i-1], y);
        y := ElementToSequence(reduce_vector_S(y));
        L_next := Matrix(S, 8, 8, [S!linear_matrices[i][j][k] : k in [1..8], j in [1..8]]);
        y := Vector(S, y) * Transpose(L_next);
        y := ElementToSequence(y);
    end for;
    return y; 
end function;




function decompose_relation(rel)
    // rel is a polynomial in S.
    MA := AssociativeArray();
    list_terms := Terms(rel);
    keys_seq:=[];
    for j in [1..#list_terms] do
        mon_j := Monomials(list_terms[j])[1];
        key := Evaluate(mon_j, [S.i : i in [1..num_par+num_par_t]] cat [1: i in [num_par+num_par_t+1..num_par+num_par_t+num_h+num_lin]] cat [S.i : i in [num_par+num_par_t+num_h+num_lin+1..num_vars]]);
        // Compute the coefficient part for the term under a different substitution:
        // for the first num_par variables use S.i and for the rest, 1.
        coeff := Evaluate(list_terms[j], [1 : i in [1..num_par+num_par_t+num_h]] cat [S.i : i in [num_par+num_par_t+num_h+1..+num_par+num_par_t+num_h+num_lin]] cat [1 : i in [num_par+num_par_t+num_h+num_lin+1..num_vars]]);
        // Accumulate: if key already exists, add; otherwise, set it.
        if IsDefined(MA, key) then
            MA[key] := MA[key] + coeff;
        else
            MA[key] := coeff;
        end if;
        keys_seq cat:=[key];
    end for;
    //return [ <k, MA[k]> : k in Keys(MA) ];
    return [MA[k] : k in remove_duplicates(keys_seq) ],[k: k in remove_duplicates(keys_seq)];
end function;



///main program




// Initial vector [x1,x2,x3,x4,x5,x6,x7,x8]
initial_vector := Vector(S, [S.(num_par+num_par_t+num_h+num_lin+i) : i in [1..num_x]]);

// Compute public key
public_key := compute_public_key(linears_ex, matrices_ex, initial_vector);

M0_E0 := &cat[[[S.(2*i-1), S.(2*i)], [S.(2*i-1), S.(2*i)]] : i in [(num_h+num_lin+num_par+num_par_t)/2+1..(num_vars-num_t)/2]];

// Generate monomial lists sequence after second exponential map, E2
mon_E2 := compute_monomial_lists_sequence(Prune(matrices_ex), M0_E0);

// Build polynomial lists
polys_front := build_polynomial_list(mon_E2);
polys_front :=psi([
    y[1]*y[921]*y[923]^32*y[925]^4 ,
    y[36]*y[921]*y[923]^32*y[925]^4 ,
    y[71]*y[921]*y[923]^32*y[925]^4 ,
    y[106]*y[921]*y[923]^32*y[925]^4 ,
    y[141]*y[921]^2*y[923]*y[927]^8,
    y[176]*y[921]^2*y[923]*y[927]^8 ,
    y[211]*y[921]^2*y[923]*y[927]^8 ,
    y[246]*y[921]^2*y[923]*y[927]^8 
]);


polys_front_c:=[&+[S.(4*(j-1)+i+(num_vars-num_lin-num_x-num_t))*polys_front[i] : i in [1..4]]: j in [1..4]] cat [&+[S.(4*(j-2)+i+(num_vars-num_lin-num_x-num_t))*polys_front[i] : i in [5..8]]: j in [5..8]];

 

polys_front_c_seq := ElementToSequence(tensor_bis(Reverse(matrices_ex)[1], polys_front_c));
polys_front_c_red := reduce_vector_S(polys_front_c_seq);
polys_front_seq := ElementToSequence(tensor_bis(Reverse(matrices_ex)[1], polys_front));
polys_front_red := reduce_vector_S(polys_front_seq);


Z4_front := polys_front_c_red;


Z4_back_a := [&+[S.(8*(j-1)+i+(num_vars-num_lin_b-num_lin_a-num_x-num_t))*polys_front_red[i] : i in [1..8]]: j in [1..8]];
Z4_back_b := [&+[S.(8*(j-1)+i+(num_vars-num_lin_b-num_x-num_t))*Z4_back_a[i] : i in [1..8]]: j in [1..8]];


Z4_relations := [Z4_front[i] + Z4_back_b[i] : i in [1..8]];



relations := Z4_relations;



// Compute final equations

list_1 := remove_duplicates(decompose_relation(relations[1]));
list_2 := remove_duplicates(decompose_relation(relations[2]));
list_3 := remove_duplicates(decompose_relation(relations[2]));
list_4 := remove_duplicates(decompose_relation(relations[2]));

list_5 := remove_duplicates(decompose_relation(relations[2]));
list_6 := remove_duplicates(decompose_relation(relations[2]));
list_7 := remove_duplicates(decompose_relation(relations[2]));
list_8 := remove_duplicates(decompose_relation(relations[2]));



st1:=Sprintf("list_1:=%o;\nlist_2:=%o;\nlist_3:=%o;\nlist_4:=%o;\nlist_5:=%o;\nlist_6:=%o;\nlist_7:=%o;\nlist_8:=%o;\n",
list_1,list_2,list_3,list_4,list_5,list_6,list_7,list_8);




PrintFile("result_ab.txt",st1: Overwrite:=true);
