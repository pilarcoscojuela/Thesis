// ========== INITIAL SETUP ========== 
// Load parameter definitions and ring setup
load "initial_setup.txt";

// ========== FUNCTION DEFINITIONS ========== 

// Reduce exponents in a polynomial modulo (q-1)
function reduce_exponents_S(poly)
    terms := Terms(poly);
    vars := [S.i : i in [1..num_vars]];
    result := Zero(S);
    for t in terms do
        exp_vec := [Degree(t, v) mod (q - 1) : v in vars];
        coef := Coefficients(t)[1];
        result +:= coef * Monomial(S, exp_vec);
    end for;
    return result;
end function;

// Apply reduce_exponents_S to each polynomial in a vector
function reduce_vector_S(vec)
    return [reduce_exponents_S(p) : p in vec];
end function;

// Compute x^(2^k) mod (q-1) via exponentiation by squaring in batches
function power_mod(x, exp)
    if exp eq 1 then
        return x;
    end if;
    modulus := q - 1;
    k := Ilog2(exp); // Number of squarings needed
    res := x;
    remaining_squarings := k;
    batch_size := 7; // Adjust based on q
    while remaining_squarings gt 0 do
        current_batch := Minimum(batch_size, remaining_squarings);
        for i in [1..current_batch] do
            res := res^2;
        end for;
        // Reduce exponents modulo (q-1) after the batch
        res := reduce_exponents_S(res);
        remaining_squarings -:= current_batch;
    end while;
    return res;
end function;

// Tensor-like product: row i of E with vector v using function power_mod
function tensor_bis(E, v)
    n := NumberOfRows(E);
    out := [Zero(S) : i in [1..n]];
    for i in [1..n] do
        out[i] := &*[power_mod(v[j],E[i][j]) : j in [1..n] | E[i][j] ne 0];
    end for;
    return out;
end function;

// Decompose a polynomial p=p1+u*p2 into two parts [p1, p2] (p1 and p2 does not depend on u)
decompose_Su := function(p)
    p1 := 0;
    p2 := 0;
    coefs := Coefficients(p);
    mons := Monomials(p);
    for i in [1..#coefs] do
        seq := ElementToSequence(coefs[i]);
        p1 +:= seq[1] * mons[i];
        p2 +:= seq[2] * mons[i];
    end for;
    return [p1, p2];
end function;

// Apply decompose_Su to each polynomial in a vector
decompose_vector := function(vec)
    out := [];
    for i in [1..#vec] do
        out cat:= decompose_Su(vec[i]);
    end for;
    return out;
end function;


function remove_duplicates(list)
    for j in [1..#list] do
    while exists(t){i : i in [1..#list]| list[i] ne 0 and i gt j and list[i] eq list[j]} do
        list[t]:=0;
    end while;
    end for;
    list_2:=[];
    for i in [1..#list] do
        if list[i] ne 0 then
            list_2:= list_2 cat [list[i]];
        end if;
    end for;
    return list_2;
end function;

// Compute monomial list output from a exponential map (mat_exp) and the monomial list of the previous round (vec). 
//Use extra_components if there are affine maps
function compute_monomial_list(mat_exp, vec, mat_extra_components)
    rows := NumberOfRows(mat_exp);
    cols := NumberOfColumns(mat_exp);
    M1 := [[] : i in [1..rows]];
    M := [[] : i in [1..rows]];
    modified_vector := vec;
    for i in [1..rows] do
        for j in [1..cols] do
            if mat_exp[i][j] ne 0 then
                exps := [power_mod(modified_vector[j][k],mat_exp[i][j]) : k in [1..#modified_vector[j]]];
                M1[i] := M1[i] cat [exps];
            end if;
        end for;
        if #M1[i] gt 0 then
            // Compute all possible products of elements in M1[i]
            M[i] := [&*[terms[k] : k in [1..#terms]] : terms in CartesianProduct(M1[i])];
        end if;
        if [mat_extra_components[2*i-1],mat_extra_components[2*i]] ne [0,0] then
            M[i] := M[i] cat [1];
        end if;
    end for;
    return [reduce_vector_S(M[j]) : j in [1..#M]];
end function;


// Apply compute_monomial_list across a sequence of matrices
function compute_monomial_lists_sequence(matrices, vec, extra_components)
    num_matrices := #matrices;
    M := vec;
    for i in [1..num_matrices] do
        M := compute_monomial_list(matrices[i], M, extra_components[i+1]);
        M := [remove_duplicates(x) : x in M];
    end for;
    return M;
end function;


//Template lists
list_q1:=[ S.i+u*S.(ctes+i): i in [1..ctes]];

list_q2:=[S.(2*ctes+i)+u*S.(3*ctes+i): i in [1..num_par/8]];

list_q3:=[S.(4*ctes+i)+u*S.(5*ctes+i): i in [1..num_par/8]];

list_q4:=[S.(6*ctes+i)+u*S.(7*ctes+i): i in [1..num_par/8]];

list_q := [list_q1, list_q2, list_q3, list_q4];

// Build polynomial list from monomial groups and template lists
function build_polynomial_list(monomial_lists)
    poly_list := [];
    for i in [1..#monomial_lists] do
        base := list_q[i];
        poly := &+[base[j] * monomial_lists[i][j] : j in [1..#monomial_lists[i]]];
        Append(~poly_list, poly);
    end for;
    return poly_list;
end function;



// Compute the public key from linear and exponential maps
function compute_public_key(linear_matrices, exp_matrices,initial_vector,extra_components)
    num_matrices := #linear_matrices;
    L0_S := Matrix(S, 8, 8, [S!linear_matrices[1][i][j] : j in [1..8], i in [1..8]]);
    L0_traspuesta := Transpose(L0_S);
    y := initial_vector * L0_traspuesta;
    y_red := [y[2*i - 1] + u * y[2*i] : i in [1..4]]; 
    y := ElementToSequence(y);
    for i in [2..num_matrices] do
        y := tensor_bis(exp_matrices[i-1], y_red);
        y := ElementToSequence(reduce_vector_S(y));
        y := decompose_vector(y);
        L_next := Matrix(S, 8, 8, [S!linear_matrices[i][j][k] : k in [1..8], j in [1..8]]);
        T_next:=Vector(S,[S!extra_components[i][j] :j in [1..8]]);
        y := Vector(S, y) * Transpose(L_next)+T_next;
        y_red:=[y[2*i - 1] + u * y[2*i] : i in [1..4]];
        y := ElementToSequence(y);
    end for;
    return y; 
end function;




// Given a polynomial, generate equations by grouping terms with the same monomial in the variables x_1,...,x_8
function decompose_relation(rel)
    // rel is a polynomial in S.
    MA := AssociativeArray();
    list_terms := Terms(rel);
    for j in [1..#list_terms] do
        mon_j := Monomials(list_terms[j])[1];
        key := Evaluate(mon_j, [1 : i in [1..num_par+num_par_t+num_h]] cat [S.i : i in [num_par+num_par_t+num_h+1..num_vars]]);
        coeff := Evaluate(list_terms[j], [S.i : i in [1..num_par+num_par_t]] cat [1 : i in [num_par+num_par_t+1..num_vars]]);
        // Accumulate: if key already exists, add; otherwise, set it.
        if IsDefined(MA, key) then
            MA[key] := MA[key] + coeff;
        else
            MA[key] := coeff;
        end if;
    end for;
    //return [ <k, MA[k]> : k in Keys(MA) ];
    return [MA[k] : k in Keys(MA) ],[k: k in Keys(MA)];
end function;

// Compute equations and relations with weight adjustments
function compute_weight_equations(vec_x_random,polys_front,weights)
    vars_w:=[S.((num_vars-num_t)+i): i in weights];
    evals:=[Evaluate(x,[S.i: i in [1..num_par+num_par_t+num_h]] cat [vars_w[i]*vec_x_random[i]: i in [1..num_x]] cat [S.i: i in [num_vars-num_t+1..num_vars]]): x in polys_front];
    list_poly_t:=[];
    list_rel_t:=[];
    for j in [1..#evals] do
        x:=evals[j];
        k:=num_par+2*(j-1)*ctes_t;
        list_x,key:=decompose_relation(x);
        rel_t:=[list_x[i]+S.(k+i)+u*S.(k+ctes_t+i) : i in [1..#list_x] ];
        p:=x+(&+[rel_t[i]*key[i]: i in [1..#list_x]]);
        list_poly_t cat:=[p];
        list_rel_t cat:=[rel_t];
    end for;
    return list_rel_t,list_poly_t;
end function;


// Public key with weight variables
function compute_weighted_public_key(vec_x_random,pub_key,weights)
    pub_key:=pub_key;
    var_w:=[S.((num_vars-num_t)+i): i in weights];
    pub_key_w:=[Evaluate(x,[S.i: i in [1..num_par+num_par_t+num_h]] cat [var_w[i]*vec_x_random[i]: i in [1..num_x]] cat [S.i: i in [num_vars-num_t+1..num_vars]]): x in pub_key]; 
    pub_key_w:=reduce_vector_S(pub_key_w);

    return pub_key_w;
end function;


// Given a polynomial unroll collisions
/*E.g. If Rt1b*Kt1 + T^12657*Rt1b*Lt1 + T^1839*St1b*Kt1 + T^9098*St1b*Lt1 
+ Rt3b*Kt3 + T^12657*Rt3b*Lt3 + T^1839*St3b*Kt3 + T^9098*St3b*Lt3 + T^10582 is a 
polynomial in a list of list_seq then 
unrolled_list will contain 
 Rt1b*Kt1 + T^12657*Rt1b*Lt1 + T^1839*St1b*Kt1 + T^9098*St1b*Lt1 
+ H2 and 
Rt3b*Kt3 + T^12657*Rt3b*Lt3 + T^1839*St3b*Kt3 + T^9098*St3b*Lt3 
+ H3
while  unrolled_list_h will contain
H2 + H3 + T^10582*/




eval_list:=&cat[[Sr.(i): i in [2*(k-1)*ctes_t+1..(2*k-1)*ctes_t]] 
            cat [Sr.(i): i in [2*(k-1)*ctes_t+1..(2*k-1)*ctes_t]]: k in [1..4] ]
            cat [0: i in [num_par_t+1..num_vars_Sr]];

function unroll_lists(list_seq,list_diff)
    out_h:=[];
    cont:=0;
    list_var_h:=[];
    for list in list_seq do 
        list_var_x_axis:={};
        list_var_y_axis:={};
        indpt_terms:=[Evaluate(p,[0 : i in [1..num_vars_Sr]]): p in list];
        list_hom:=[list[i]+indpt_terms[i]: i in [1..#list]];
        unrolled_list_h:=[];
        for j in [1..#list_hom] do
           
            mon_diff:=[Evaluate(x,list_diff): x in Monomials(list_hom[j])];
            ass_mon_diff:=AssociativeArray(mon_diff);
            for k in mon_diff do
                ass_mon_diff[k]:=&+[y: y in Terms(list_hom[j])| Evaluate(Monomials(y)[1],list_diff) eq k];
            end for;
            ass_mon_diff_list:=[ass_mon_diff[k]: k in Keys(ass_mon_diff)];
            list_var_x_axis join:={&+{Evaluate(y,eval_list) div k : y in Monomials(ass_mon_diff[k])} : k in Keys(ass_mon_diff)};
           
            list_var_y_axis join:={k : k in Keys(ass_mon_diff)};
           
                //for x in Keys(ass_mon_diff) do x, ass_mon_diff[x]; end for;
           count:=#Keys(ass_mon_diff);
           if count gt 1 then 
            acum:=&+[Sr.(num_par_t+cont+i):i in [1..(count-1)]];
            L:=[Sr.(num_par_t+cont+i)+ass_mon_diff_list[i] : i in [1..(count-1)]] cat [ass_mon_diff_list[count] + acum +indpt_terms[j]];
            cont+:=#L-1;
            else
            L:=[ass_mon_diff_list[1]+indpt_terms[j]];
            end if;
             unrolled_list_h cat:=[x: x in L];
        end for;
        out_h cat:=[unrolled_list_h];
        list_var_h cat:=[[list_var_x_axis,list_var_y_axis]];
    end for;
    return list_var_h,out_h;
end function;



// ========== MAIN PROGRAM ========== 

// Initial vector [x1,x2,x3,x4,x5,x6,x7,x8]
initial_vector := Vector(S, [S.(num_par+num_par_t+num_h+i) : i in [1..num_x]]);

// Compute public key
public_key := compute_public_key(linears_ex, matrices_ex, initial_vector,translation);

// M0_E0:=[[x_1,x_2],[x_1,x_2],[x_3,x_4],[x_3,x_4],[x_5,x_6],[x_5,x_6],[x_7,x_8],[x_7,x_8]]
M0_E0 := [[S.(2*i-1), S.(2*i)] : i in [(num_h+num_par+num_par_t)/2+1..(num_vars-num_t)/2]];

// Generate monomial lists sequence after second exponential map, E2
mon_E2 := compute_monomial_lists_sequence(Prune(matrices_ex), M0_E0, translation);

// Public key with weights
weighted_public_key := compute_weighted_public_key(vec_x_random_ex, public_key, vector_weights_ex);

// Build polynomial lists
polys_E2 := build_polynomial_list(mon_E2);

//Reduce variables using weights
equations_w, polys_E2_weighted:= compute_weight_equations(vec_x_random_ex, polys_E2, vector_weights_ex);

//Compute output after E2 with and without weights
polys_E2_seq := ElementToSequence(tensor_bis(Reverse(matrices_ex)[1], polys_E2));
polys_E2_seq_red := reduce_vector_S(polys_E2_seq);
polys_E2_weighted_seq := ElementToSequence(tensor_bis(Reverse(matrices_ex)[1],  polys_E2_weighted));
polys_E2_weighted_seq_red := reduce_vector_S(polys_E2_weighted_seq);


polys_front := polys_E2_seq_red;
polys_weighted_front := polys_E2_weighted_seq_red;

//Public key polynomials and also output after E3 because in DME minus last linear map 
//can be assumed to be the identity map
polys_back := [public_key[2*i - 1] : i in [1..4]];
polys_weighted_back := [weighted_public_key[2*i - 1] : i in [1..4]];

//System of equations
polys_front_odd := [decompose_vector(polys_front)[i] : i in [1, 3, 5, 7]];
polys_relations := [polys_front_odd[i] + polys_back[i] : i in [1..4]];
relations := polys_relations;

//System of equations with weights
polys_front_weighted_odd := [decompose_vector(polys_weighted_front)[i] : i in [1, 3, 5, 7]];
polys_weighted_relations := [polys_front_weighted_odd[i] + polys_weighted_back[i] : i in [1..4]];
relations_weighted := polys_weighted_relations;



//Grouping for each polynomial in relations the terms that have the same monomial in x1,...,x8
list_1 :=[phi(x): x in decompose_relation(relations[1])];
list_2 := [phi(x): x in decompose_relation(relations[2])];
list_3 := [phi(x): x in decompose_relation(relations[3])];
list_4 := [phi(x): x in decompose_relation(relations[4])];


//Grouping for each polynomial in relations_weighted the terms that have the same monomial in t1,...,t6
list_w_1 := decompose_relation(relations_weighted[1]);
list_w_2 := decompose_relation(relations_weighted[2]);
list_w_3 := decompose_relation(relations_weighted[3]);
list_w_4 := decompose_relation(relations_weighted[4]);





//Simplify some of the exponents of the computed equations
load "simplify.txt";

list_w_1_simp:=restr(list_w_1);
list_w_2_simp:=restr(list_w_2);
list_w_3_simp:=restr(list_w_3);
list_w_4_simp:=restr(list_w_4);

st1:=Sprintf("list_w_1:=%o;\nlist_w_2:=%o;\nlist_w_3:=%o;\nlist_w_4:=%o;\n",list_w_1_simp,list_w_2_simp,list_w_3_simp,list_w_4_simp);
st2:=Sprintf("list_w_1:=%o;\nlist_w_2:=%o;\n",inv_restr(list_w_1_simp),inv_restr(list_w_2_simp));

PrintFile("result.txt",st1: Overwrite:=true);

PrintFile("components_1_and_2.txt",st2: Overwrite:=true);

//Remove exponents
System("python3 remove_exp.py");

load "result_without_exp.txt";






//Compute linear system that relates Ri,Si,Ki,Li,Zi,Wi,Xi,Yi with Rti,Sti,Kti,Lti,Zti,Wti,Xti,Yti
equations_weighted_decom:=decompose_vector(&cat[x: x in equations_w]);
linear_system:=[Evaluate(x,[S.i: i in [1..num_vars]]): x in equations_weighted_decom];

PrintFile("linear_system.txt",Sprint([linear_system]):Overwrite:=true);


//Syzygies 1: obtained by combining rows one and two of E_3

eval_zx_diff:=&cat[[1: i in [2*(k-1)*ctes_t+1..(2*k-1)*ctes_t]] 
            cat [1: i in [1..ctes_t]]: k in [1..2] ]
            cat &cat[[Sr.(i): i in [2*(k-1)*ctes_t+1..(2*k-1)*ctes_t]] 
            cat [Sr.(i): i in [2*(k-1)*ctes_t+1..(2*k-1)*ctes_t]]: k in [3..4] ]
            cat [0: i in [num_par_t+1..num_vars_Sr]];

list_var_h,ecs_h:=unroll_lists([list_w_1,list_w_2,list_w_3,list_w_4],eval_zx_diff);


[{inv_restr(Evaluate(x,eval_list)) :x in Monomials(y)}:y in list_w_1];
[{inv_restr(Evaluate(x,eval_list))  :x in Monomials(y)}:y in list_w_2];
[{inv_restr(Evaluate(x,eval_list))  :x in Monomials(y)}:y in list_w_3];
[{inv_restr(Evaluate(x,eval_list))  :x in Monomials(y)}:y in list_w_4];

var_x_axis:=[x: x in SetToSequence(list_var_h[1][1])];

var_y_axis:=[x: x in SetToSequence(list_var_h[1][2]) cat SetToSequence(list_var_h[2][2])];


eval_h_Sr:=[0: i in [1..num_par_t]] cat [Sr.i: i in [num_par_t+1..num_vars_Sr]];

matrices_zx:=function(I,dim)
        entries:=ZeroMatrix(Sr,dim,dim+dim);
        
        for x in I do
                h_x:=Evaluate(x,eval_h_Sr);
                x_hom:=x+h_x;
                term_set_y:=&+{Evaluate(t,eval_zx_diff): t in Monomials(x_hom)};
                term_set_x:=&+{Evaluate(t,eval_list) div Evaluate(t,eval_zx_diff) : t in Monomials(x_hom)};
            
                ind_x:=Index(var_x_axis, term_set_x);
                ind_y:=Index(var_y_axis,term_set_y); 

               
                entries[ind_x][ind_y]:=h_x;
                
        end for;
        
        entries:=Transpose(RemoveZeroRows(Transpose(entries)));
        RemoveZeroRows(~entries);
        return NumberOfRows(entries),NumberOfColumns(entries),entries;
end function;

rows_1,cols_1,mat_tot_zx:=matrices_zx([x: x in ecs_h[1] cat ecs_h[2]],40);



SetVerbose("Faugere",1);
G1:=GroebnerBasis(Minors(mat_tot_zx,3));



vars_Sr:=[j: j in z];
sol_h:=vars_Sr;
for x in G1 do
indx:=Index(vars_Sr,LeadingMonomial(x));
sol_h[indx]:=Evaluate(x,[0: i in z]);
end for;


simp_1:=[Evaluate(y,sol_h): y in ecs_h[1]];


//Syzygies 2: obtained by combining rows one and four of E_3

eval_rx_diff:= &cat[[Sr.i: i in [2*(k-1)*ctes_t+1..(2*k-1)*ctes_t]] 
            cat [Sr.i: i in [2*(k-1)*ctes_t+1..(2*k-1)*ctes_t]]: k in [1] ] 
            cat 
            &cat[[1: i in [2*(k-1)*ctes_t+1..(2*k-1)*ctes_t]] 
            cat [1: i in [2*(k-1)*ctes_t+1..(2*k-1)*ctes_t]]: k in [2..3] ]
            cat 
            &cat[[Sr.i: i in [2*(k-1)*ctes_t+1..(2*k-1)*ctes_t]] 
            cat [Sr.i: i in [2*(k-1)*ctes_t+1..(2*k-1)*ctes_t]]: k in [4] ]
            cat [0: i in [num_par_t+1..num_vars_Sr]];





list_var_h,ecs_h:=unroll_lists([list_w_1,list_w_2,list_w_3,list_w_4],eval_rx_diff);


var_x_axis:=[x: x in SetToSequence(list_var_h[1][1])];

var_y_axis:=[x: x in SetToSequence(list_var_h[1][2]) cat SetToSequence(list_var_h[4][2])];


eval_h_Sr:=[0: i in [1..num_par_t]] cat [Sr.i: i in [num_par_t+1..num_vars_Sr]];

matrices_rx:=function(I,dim)
        entries:=ZeroMatrix(Sr,dim,dim+dim);
        
        for x in I do
                h_x:=Evaluate(x,eval_h_Sr);
                x_hom:=x+h_x;
                term_set_y:=&+{Evaluate(t,eval_rx_diff): t in Monomials(x_hom)};
                term_set_x:=&+{Evaluate(t,eval_list) div Evaluate(t,eval_rx_diff) : t in Monomials(x_hom)};
            
                ind_x:=Index(var_x_axis, term_set_x);
                ind_y:=Index(var_y_axis,term_set_y); 
                

               
                entries[ind_x][ind_y]:=h_x;
                
        end for;
        
        entries:=Transpose(RemoveZeroRows(Transpose(entries)));
        RemoveZeroRows(~entries);
        return NumberOfRows(entries),NumberOfColumns(entries),entries;
end function;

rows_2,cols_2,mat_tot_rx:=matrices_rx([x: x in ecs_h[1] cat ecs_h[4]],40);


G2:=GroebnerBasis(Minors(mat_tot_rx,3));
/* <z[72] + T^798, 1>,
    <z[72] + T^255, 1>,*/
G2_p:=[
    z[49] + T^57,
    z[50] + T^856,
    z[51] + T^308,
    z[52] + T^252,
    z[53] + T^293,
    z[54] + T^703,
    z[67] + T^5,
    z[68] + T^954,
    z[69] + T^881,
    z[70] + T^692,
    z[71] + T^546,
    z[72] + T^255
];
vars_Sr:=[j: j in z];
sol_h:=vars_Sr;
for x in G2_p do
indx:=Index(vars_Sr,LeadingMonomial(x));
sol_h[indx]:=Evaluate(x,[0: i in z]);
end for;


simp_2:=[Evaluate(y,sol_h): y in ecs_h[1]];

/*
[inv_restr(x): x in simp_2];
[
    Rt2*Kt1*Zt3 + T^929*Rt2*Kt1*Wt3 + Rt2*Kt3*Zt4 + T^929*Rt2*Kt3*Wt4 + T^159*Rt2*Lt1*Zt3 + T^715*Rt2*Lt1*Wt3 + T^159*Rt2*Lt3*Zt4 + T^715*Rt2*Lt3*Wt4 + T^159*St2*Kt1*Zt3 + 
        T^715*St2*Kt1*Wt3 + T^159*St2*Kt3*Zt4 + T^715*St2*Kt3*Wt4 + T^985*St2*Lt1*Wt3 + T^985*St2*Lt3*Wt4 + T^57,
    Rt1*Kt3*Zt3 + T^929*Rt1*Kt3*Wt3 + T^159*Rt1*Lt3*Zt3 + T^715*Rt1*Lt3*Wt3 + T^159*St1*Kt3*Zt3 + T^715*St1*Kt3*Wt3 + T^985*St1*Lt3*Wt3 + T^889,
    Rt2*Kt1*Zt2 + T^929*Rt2*Kt1*Wt2 + Rt2*Kt2*Zt1 + T^929*Rt2*Kt2*Wt1 + T^159*Rt2*Lt1*Zt2 + T^715*Rt2*Lt1*Wt2 + T^159*Rt2*Lt2*Zt1 + T^715*Rt2*Lt2*Wt1 + T^159*St2*Kt1*Zt2 + 
        T^715*St2*Kt1*Wt2 + T^159*St2*Kt2*Zt1 + T^715*St2*Kt2*Wt1 + T^985*St2*Lt1*Wt2 + T^985*St2*Lt2*Wt1 + T^856,
    Rt1*Kt1*Zt1 + T^929*Rt1*Kt1*Wt1 + Rt1*Kt3*Zt2 + T^929*Rt1*Kt3*Wt2 + T^159*Rt1*Lt1*Zt1 + T^715*Rt1*Lt1*Wt1 + T^159*Rt1*Lt3*Zt2 + T^715*Rt1*Lt3*Wt2 + T^159*St1*Kt1*Zt1 + 
        T^715*St1*Kt1*Wt1 + T^159*St1*Kt3*Zt2 + T^715*St1*Kt3*Wt2 + T^985*St1*Lt1*Wt1 + T^985*St1*Lt3*Wt2 + T^865,
    Rt2*Kt1*Zt4 + T^929*Rt2*Kt1*Wt4 + Rt2*Kt2*Zt3 + T^929*Rt2*Kt2*Wt3 + T^159*Rt2*Lt1*Zt4 + T^715*Rt2*Lt1*Wt4 + T^159*Rt2*Lt2*Zt3 + T^715*Rt2*Lt2*Wt3 + T^159*St2*Kt1*Zt4 + 
        T^715*St2*Kt1*Wt4 + T^159*St2*Kt2*Zt3 + T^715*St2*Kt2*Wt3 + T^985*St2*Lt1*Wt4 + T^985*St2*Lt2*Wt3 + T^308,
    Rt1*Kt1*Zt3 + T^929*Rt1*Kt1*Wt3 + Rt1*Kt3*Zt4 + T^929*Rt1*Kt3*Wt4 + T^159*Rt1*Lt1*Zt3 + T^715*Rt1*Lt1*Wt3 + T^159*Rt1*Lt3*Zt4 + T^715*Rt1*Lt3*Wt4 + T^159*St1*Kt1*Zt3 + 
        T^715*St1*Kt1*Wt3 + T^159*St1*Kt3*Zt4 + T^715*St1*Kt3*Wt4 + T^985*St1*Lt1*Wt3 + T^985*St1*Lt3*Wt4 + T^973,
    Rt2*Kt2*Zt4 + T^929*Rt2*Kt2*Wt4 + T^159*Rt2*Lt2*Zt4 + T^715*Rt2*Lt2*Wt4 + T^159*St2*Kt2*Zt4 + T^715*St2*Kt2*Wt4 + T^985*St2*Lt2*Wt4 + T^252,
    Rt1*Kt1*Zt4 + T^929*Rt1*Kt1*Wt4 + Rt1*Kt2*Zt3 + T^929*Rt1*Kt2*Wt3 + T^159*Rt1*Lt1*Zt4 + T^715*Rt1*Lt1*Wt4 + T^159*Rt1*Lt2*Zt3 + T^715*Rt1*Lt2*Wt3 + T^159*St1*Kt1*Zt4 + 
        T^715*St1*Kt1*Wt4 + T^159*St1*Kt2*Zt3 + T^715*St1*Kt2*Wt3 + T^985*St1*Lt1*Wt4 + T^985*St1*Lt2*Wt3 + T^436,
    Rt2*Kt3*Zt1 + T^929*Rt2*Kt3*Wt1 + T^159*Rt2*Lt3*Zt1 + T^715*Rt2*Lt3*Wt1 + T^159*St2*Kt3*Zt1 + T^715*St2*Kt3*Wt1 + T^985*St2*Lt3*Wt1 + T^449,
    Rt1*Kt2*Zt4 + T^929*Rt1*Kt2*Wt4 + T^159*Rt1*Lt2*Zt4 + T^715*Rt1*Lt2*Wt4 + T^159*St1*Kt2*Zt4 + T^715*St1*Kt2*Wt4 + T^985*St1*Lt2*Wt4 + T^26,
    Rt2*Kt2*Zt2 + T^929*Rt2*Kt2*Wt2 + T^159*Rt2*Lt2*Zt2 + T^715*Rt2*Lt2*Wt2 + T^159*St2*Kt2*Zt2 + T^715*St2*Kt2*Wt2 + T^985*St2*Lt2*Wt2 + T^293,
    Rt1*Kt1*Zt2 + T^929*Rt1*Kt1*Wt2 + Rt1*Kt2*Zt1 + T^929*Rt1*Kt2*Wt1 + T^159*Rt1*Lt1*Zt2 + T^715*Rt1*Lt1*Wt2 + T^159*Rt1*Lt2*Zt1 + T^715*Rt1*Lt2*Wt1 + T^159*St1*Kt1*Zt2 + 
        T^715*St1*Kt1*Wt2 + T^159*St1*Kt2*Zt1 + T^715*St1*Kt2*Wt1 + T^985*St1*Lt1*Wt2 + T^985*St1*Lt2*Wt1 + T^271,
    Rt1*Kt2*Zt2 + T^929*Rt1*Kt2*Wt2 + T^159*Rt1*Lt2*Zt2 + T^715*Rt1*Lt2*Wt2 + T^159*St1*Kt2*Zt2 + T^715*St1*Kt2*Wt2 + T^985*St1*Lt2*Wt2 + T^640,
    Rt2*Kt1*Zt1 + T^929*Rt2*Kt1*Wt1 + Rt2*Kt3*Zt2 + T^929*Rt2*Kt3*Wt2 + T^159*Rt2*Lt1*Zt1 + T^715*Rt2*Lt1*Wt1 + T^159*Rt2*Lt3*Zt2 + T^715*Rt2*Lt3*Wt2 + T^159*St2*Kt1*Zt1 + 
        T^715*St2*Kt1*Wt1 + T^159*St2*Kt3*Zt2 + T^715*St2*Kt3*Wt2 + T^985*St2*Lt1*Wt1 + T^985*St2*Lt3*Wt2 + T^703,
    Rt1*Kt3*Zt1 + T^929*Rt1*Kt3*Wt1 + T^159*Rt1*Lt3*Zt1 + T^715*Rt1*Lt3*Wt1 + T^159*St1*Kt3*Zt1 + T^715*St1*Kt3*Wt1 + T^985*St1*Lt3*Wt1 + T^219,
    Rt2*Kt3*Zt3 + T^929*Rt2*Kt3*Wt3 + T^159*Rt2*Lt3*Zt3 + T^715*Rt2*Lt3*Wt3 + T^159*St2*Kt3*Zt3 + T^715*St2*Kt3*Wt3 + T^985*St2*Lt3*Wt3 + T^139
]
> [inv_restr(x): x in simp_1];
[
    Rt2*Kt3*Zt4 + T^929*Rt2*Kt3*Wt4 + T^159*Rt2*Lt3*Zt4 + T^715*Rt2*Lt3*Wt4 + T^159*St2*Kt3*Zt4 + T^715*St2*Kt3*Wt4 + T^985*St2*Lt3*Wt4 + T^576,
    Rt1*Kt3*Zt3 + T^929*Rt1*Kt3*Wt3 + T^159*Rt1*Lt3*Zt3 + T^715*Rt1*Lt3*Wt3 + Rt2*Kt1*Zt3 + T^929*Rt2*Kt1*Wt3 + T^159*Rt2*Lt1*Zt3 + T^715*Rt2*Lt1*Wt3 + T^159*St1*Kt3*Zt3 + 
        T^715*St1*Kt3*Wt3 + T^985*St1*Lt3*Wt3 + T^159*St2*Kt1*Zt3 + T^715*St2*Kt1*Wt3 + T^985*St2*Lt1*Wt3 + T^493,
    Rt1*Kt1*Zt1 + T^929*Rt1*Kt1*Wt1 + T^159*Rt1*Lt1*Zt1 + T^715*Rt1*Lt1*Wt1 + Rt2*Kt2*Zt1 + T^929*Rt2*Kt2*Wt1 + T^159*Rt2*Lt2*Zt1 + T^715*Rt2*Lt2*Wt1 + T^159*St1*Kt1*Zt1 + 
        T^715*St1*Kt1*Wt1 + T^985*St1*Lt1*Wt1 + T^159*St2*Kt2*Zt1 + T^715*St2*Kt2*Wt1 + T^985*St2*Lt2*Wt1 + T^1020,
    Rt1*Kt3*Zt2 + T^929*Rt1*Kt3*Wt2 + T^159*Rt1*Lt3*Zt2 + T^715*Rt1*Lt3*Wt2 + Rt2*Kt1*Zt2 + T^929*Rt2*Kt1*Wt2 + T^159*Rt2*Lt1*Zt2 + T^715*Rt2*Lt1*Wt2 + T^159*St1*Kt3*Zt2 + 
        T^715*St1*Kt3*Wt2 + T^985*St1*Lt3*Wt2 + T^159*St2*Kt1*Zt2 + T^715*St2*Kt1*Wt2 + T^985*St2*Lt1*Wt2 + T^368,
    Rt1*Kt3*Zt4 + T^929*Rt1*Kt3*Wt4 + T^159*Rt1*Lt3*Zt4 + T^715*Rt1*Lt3*Wt4 + Rt2*Kt1*Zt4 + T^929*Rt2*Kt1*Wt4 + T^159*Rt2*Lt1*Zt4 + T^715*Rt2*Lt1*Wt4 + T^159*St1*Kt3*Zt4 + 
        T^715*St1*Kt3*Wt4 + T^985*St1*Lt3*Wt4 + T^159*St2*Kt1*Zt4 + T^715*St2*Kt1*Wt4 + T^985*St2*Lt1*Wt4 + T^885,
    Rt1*Kt1*Zt3 + T^929*Rt1*Kt1*Wt3 + T^159*Rt1*Lt1*Zt3 + T^715*Rt1*Lt1*Wt3 + Rt2*Kt2*Zt3 + T^929*Rt2*Kt2*Wt3 + T^159*Rt2*Lt2*Zt3 + T^715*Rt2*Lt2*Wt3 + T^159*St1*Kt1*Zt3 + 
        T^715*St1*Kt1*Wt3 + T^985*St1*Lt1*Wt3 + T^159*St2*Kt2*Zt3 + T^715*St2*Kt2*Wt3 + T^985*St2*Lt2*Wt3 + T^179,
    Rt1*Kt1*Zt4 + T^929*Rt1*Kt1*Wt4 + T^159*Rt1*Lt1*Zt4 + T^715*Rt1*Lt1*Wt4 + Rt2*Kt2*Zt4 + T^929*Rt2*Kt2*Wt4 + T^159*Rt2*Lt2*Zt4 + T^715*Rt2*Lt2*Wt4 + T^159*St1*Kt1*Zt4 + 
        T^715*St1*Kt1*Wt4 + T^985*St1*Lt1*Wt4 + T^159*St2*Kt2*Zt4 + T^715*St2*Kt2*Wt4 + T^985*St2*Lt2*Wt4 + T^387,
    Rt1*Kt2*Zt3 + T^929*Rt1*Kt2*Wt3 + T^159*Rt1*Lt2*Zt3 + T^715*Rt1*Lt2*Wt3 + T^159*St1*Kt2*Zt3 + T^715*St1*Kt2*Wt3 + T^985*St1*Lt2*Wt3 + T^253,
    Rt2*Kt3*Zt1 + T^929*Rt2*Kt3*Wt1 + T^159*Rt2*Lt3*Zt1 + T^715*Rt2*Lt3*Wt1 + T^159*St2*Kt3*Zt1 + T^715*St2*Kt3*Wt1 + T^985*St2*Lt3*Wt1 + T^449,
    Rt1*Kt2*Zt4 + T^929*Rt1*Kt2*Wt4 + T^159*Rt1*Lt2*Zt4 + T^715*Rt1*Lt2*Wt4 + T^159*St1*Kt2*Zt4 + T^715*St1*Kt2*Wt4 + T^985*St1*Lt2*Wt4 + T^26,
    Rt1*Kt2*Zt1 + T^929*Rt1*Kt2*Wt1 + T^159*Rt1*Lt2*Zt1 + T^715*Rt1*Lt2*Wt1 + T^159*St1*Kt2*Zt1 + T^715*St1*Kt2*Wt1 + T^985*St1*Lt2*Wt1 + T^968,
    Rt1*Kt1*Zt2 + T^929*Rt1*Kt1*Wt2 + T^159*Rt1*Lt1*Zt2 + T^715*Rt1*Lt1*Wt2 + Rt2*Kt2*Zt2 + T^929*Rt2*Kt2*Wt2 + T^159*Rt2*Lt2*Zt2 + T^715*Rt2*Lt2*Wt2 + T^159*St1*Kt1*Zt2 + 
        T^715*St1*Kt1*Wt2 + T^985*St1*Lt1*Wt2 + T^159*St2*Kt2*Zt2 + T^715*St2*Kt2*Wt2 + T^985*St2*Lt2*Wt2 + T^763,
    Rt1*Kt2*Zt2 + T^929*Rt1*Kt2*Wt2 + T^159*Rt1*Lt2*Zt2 + T^715*Rt1*Lt2*Wt2 + T^159*St1*Kt2*Zt2 + T^715*St1*Kt2*Wt2 + T^985*St1*Lt2*Wt2 + T^640,
    Rt1*Kt3*Zt1 + T^929*Rt1*Kt3*Wt1 + T^159*Rt1*Lt3*Zt1 + T^715*Rt1*Lt3*Wt1 + Rt2*Kt1*Zt1 + T^929*Rt2*Kt1*Wt1 + T^159*Rt2*Lt1*Zt1 + T^715*Rt2*Lt1*Wt1 + T^159*St1*Kt3*Zt1 + 
        T^715*St1*Kt3*Wt1 + T^985*St1*Lt3*Wt1 + T^159*St2*Kt1*Zt1 + T^715*St2*Kt1*Wt1 + T^985*St2*Lt1*Wt1 + T^834,
    Rt2*Kt3*Zt2 + T^929*Rt2*Kt3*Wt2 + T^159*Rt2*Lt3*Zt2 + T^715*Rt2*Lt3*Wt2 + T^159*St2*Kt3*Zt2 + T^715*St2*Kt3*Wt2 + T^985*St2*Lt3*Wt2 + T^742,
    Rt2*Kt3*Zt3 + T^929*Rt2*Kt3*Wt3 + T^159*Rt2*Lt3*Zt3 + T^715*Rt2*Lt3*Wt3 + T^159*St2*Kt3*Zt3 + T^715*St2*Kt3*Wt3 + T^985*St2*Lt3*Wt3 + T^139
]


*/





//Syzygies 3: obtained by combining rows one and three of E_3


eval_kx_diff:= &cat[[1: i in [2*(k-1)*ctes_t+1..(2*k-1)*ctes_t]] 
            cat [1: i in [2*(k-1)*ctes_t+1..(2*k-1)*ctes_t]]: k in [1] ] 
            cat 
            &cat[[Sr.i: i in [2*(k-1)*ctes_t+1..(2*k-1)*ctes_t]] 
            cat [Sr.i: i in [2*(k-1)*ctes_t+1..(2*k-1)*ctes_t]]: k in [2] ]
            cat 
            &cat[[1: i in [2*(k-1)*ctes_t+1..(2*k-1)*ctes_t]] 
            cat [1: i in [2*(k-1)*ctes_t+1..(2*k-1)*ctes_t]]: k in [3] ]
            cat 
            &cat[[Sr.i: i in [2*(k-1)*ctes_t+1..(2*k-1)*ctes_t]] 
            cat [Sr.i: i in [2*(k-1)*ctes_t+1..(2*k-1)*ctes_t]]: k in [4] ]
            cat [0: i in [num_par_t+1..num_vars_Sr]];





list_var_h,ecs_h:=unroll_lists([list_w_1,list_w_2,list_w_3,list_w_4],eval_kx_diff);


var_x_axis:=[x: x in SetToSequence(list_var_h[1][1])];

var_y_axis:=[x: x in SetToSequence(list_var_h[1][2]) cat SetToSequence(list_var_h[3][2])];


eval_h_Sr:=[0: i in [1..num_par_t]] cat [Sr.i: i in [num_par_t+1..num_vars_Sr]];

matrices_kx:=function(I,dim)
        entries:=ZeroMatrix(Sr,dim,dim+dim);
        
        for x in I do
                h_x:=Evaluate(x,eval_h_Sr);
                x_hom:=x+h_x;
                term_set_y:=&+{Evaluate(t,eval_kx_diff): t in Monomials(x_hom)};
                term_set_x:=&+{Evaluate(t,eval_list) div Evaluate(t,eval_kx_diff) : t in Monomials(x_hom)};
            
                ind_x:=Index(var_x_axis, term_set_x);
                ind_y:=Index(var_y_axis,term_set_y); 
                
               
                entries[ind_x][ind_y]:=h_x;
                
        end for;
        
        entries:=Transpose(RemoveZeroRows(Transpose(entries)));
        RemoveZeroRows(~entries);
        return NumberOfRows(entries),NumberOfColumns(entries),entries;
end function;

rows_3,cols_3,mat_tot_kx:=matrices_kx([x: x in ecs_h[1] cat ecs_h[3]],40);


G3:=GroebnerBasis(Minors(mat_tot_kx,3));


G1;G2;G3;